[
  {
    "objectID": "overview.html",
    "href": "overview.html",
    "title": "Overview",
    "section": "",
    "text": "Draft Supporting Information (in review)\n\n\n\nThis site provides a demonstrative workflow and supporting information for the publication:\nMechanistic Insights into the 2014-2015 Vesicular Stomatitis Outbreak in the United States: A SEIR-SEI Compartmental Model Analysis\nAuthors:\nHumphreys, Pelzel-McCluskey, Shults, Velazquez Salinas, Bertram, McGregor, Cohnstaedt, Swanson, Scroggs, Peters, and Rodriguez"
  },
  {
    "objectID": "overview.html#workflow-synopsis",
    "href": "overview.html#workflow-synopsis",
    "title": "Overview",
    "section": "Workflow Synopsis",
    "text": "Workflow Synopsis\nThis script provides an overview of the methodologies and code presented in the publication above. Note that data, code, and website configuration files, as well as code for the VSV ShinyApp, are available on the project’s GitHub site.\nFor simplicity, this workflow will demonstrate analysis for outbreaks observed in 2014, however the workflow can be applied 2015 outbreaks with minimal modification. The PAGE CONTENTS menu in the right upper corner can be used to navigate to specific sections."
  },
  {
    "objectID": "overview.html#parameters-and-formula",
    "href": "overview.html#parameters-and-formula",
    "title": "Overview",
    "section": "Parameters and Formula",
    "text": "Parameters and Formula\n\nModel Parameters\nBrief descriptions of parameters used in the model. Note that additional information and cited sources for selected parameter values are provided in the associated publication.\n\n\n\\begin{array}{|c|l|}\n  \\hline\n  \\text{Parameter} & \\text{Description} \\\\\n  \\hline\n  N_h & \\text{Total number of vertebrate hosts} \\\\\n  N_v & \\text{Total number of insect vectors} \\\\\n  \\upsilon_h & \\text{Contact rate, bites sustained by host} \\\\\n  \\upsilon_v & \\text{Contact rate, vector biting rate} \\\\\n  \\beta_h & \\text{Vector to host transmission probability} \\\\\n  \\beta_v & \\text{Host to vector transmission probability}  \\\\\n  \\sigma_h & \\text{Intrinsic Incubation Period (IIP)} \\\\\n  \\sigma_v & \\text{Extrinsic Incubation Period (EIP)} \\\\\n  \\gamma_h & \\text{Host removal rate (recovery or quarantine)} \\\\\n  \\rho_h & \\text{Host heterogeneous competency} \\\\\n  \\rho_v & \\text{Vector heterogeneous competency} \\\\\n  \\mu_v & \\text{Vector background mortality rate} \\\\\n  \\kappa & \\text{Observation bias (proportion observed)} \\\\\n  \\hline\n\\end{array}\n\n\n\n\nModel Specification\nMechanistic aspects of the model can can be diagrammatically represented as shown below. Note that in case of both the vertebrate hosts (h subscript) and vectors (v subscript), the term \\rho influences the number of exposed individuals (E) that proceed to the infectiousness compartment (I).\n\nMore formally, the model is given as: \n\\begin{align}\n    \\lambda_h &= \\upsilon_h \\cdot \\beta_h \\cdot \\frac{I_v}{N_v} \\\\\n    \\lambda_v &= \\upsilon_v \\cdot \\beta_v \\cdot \\frac{I_h}{N_h} \\\\\n    \\frac{dS_h}{dt} &= -\\lambda_h \\cdot S_h \\\\\n    \\frac{dE_h}{dt} &=  \\lambda_h \\cdot S_h - \\sigma_h \\cdot E_h \\\\\n    \\frac{dI_h}{dt} &= \\sigma_h \\cdot E_h \\cdot \\rho_h - \\gamma_h \\cdot I_h \\\\\n    \\frac{dR_h}{dt} &=  \\gamma_h \\cdot I_h  \\\\\n    \\frac{dS_v}{dt} &= \\mu_v \\cdot N_v - \\lambda_v \\cdot S_v - \\mu_v \\cdot S_v \\\\\n    \\frac{dE_v}{dt} &= \\lambda_v \\cdot S_v - (\\sigma_v + \\mu_v) \\cdot E_v \\\\\n    \\frac{dI_v}{dt} &=  \\sigma_v \\cdot E_v \\cdot \\rho_v - \\mu_v \\cdot I_v \\\\ \\nonumber\n\\end{align} \\tag{1}\nin which the first two lines give the Force of Infection (FOI, \\lambda’s) for hosts and vectors respectively and \\rho parameters (range 0.00-1.00) potentially reduce the size of the exposed (E) populations used in calculating the number of infectious individuals (I)."
  },
  {
    "objectID": "overview.html#model-preliminaries",
    "href": "overview.html#model-preliminaries",
    "title": "Overview",
    "section": "Model Preliminaries",
    "text": "Model Preliminaries\nBefore constructing a Bayesian model in Stan, we first visualize the data and construct an exploratory compartmental model using non-Bayesian Ordinary Differential Equations (ODE) and the deSolve Package.\n\nNeeded Libraries\nLoad needed R-Packages and custom functions.\n\n\nHide code\nlibrary(here) # to manage directories\nlibrary(tidyverse) # data wrangling\nlibrary(deSolve) # for exploratory models\nlibrary(ggdist) # visualizations\nlibrary(rstan) # interface with Stan from R\nrstan_options(auto_write = TRUE) # options\noptions(mc.cores = parallel::detectCores())\n\nlibrary(cmdstanr) # additional Stan options in R\ncheck_cmdstan_toolchain(fix = TRUE, quiet = TRUE)\nregister_knitr_engine()\n\n# custom functions (mostly plotting)  \nsource(here(\"./R/utilities.R\"))\nsource_dir(\"./R\")\n\n\n\n\nObserved Incidence\nRead observed incidence data and create a simple plot figure. Note that 2014 and 2015 data are available in the vsv_ind_truth.rds object.\n\nContents for vsv_ind_truth.rds\n\ndate: Estimated date of disease onset (symptoms) as determined by examination at time of inspection.\n\ncount: Number of individuals animals with Vesicular Stomatitis (VS)\n\nsusc: Number of individual animals located with same herd or on same premises as confirmed animal. These values are assumed to reflect susceptible animals.\n\nyear: Year of confirmed VS onset.\n\ndoy: Integer 1-365 reflecting the day of year for the date.\n\n\n\nHide code\ntruth_df <- readRDS(here(\"assets/vsv_ind_truth.rds\")) |>\n  filter(year == 2014) # cahnge to 2015 to examine 2015 data\n\nstr(truth_df)\n\n\n'data.frame':   117 obs. of  5 variables:\n $ date : Date, format: \"2014-05-18\" \"2014-05-29\" ...\n $ count: int  4 1 1 1 2 1 1 2 4 1 ...\n $ susc : int  65 3 3 5 4 1 11 79 7 6 ...\n $ year : num  2014 2014 2014 2014 2014 ...\n $ doy  : num  138 149 150 158 159 163 166 174 184 188 ...\n\n\n\n\nHide code\nplot_incidence(truth_df)\n\n\n\n\n\nFigure 1: Observed VS incidence 2014.\n\n\n\n\n\n\n\nExploratory Model\nBefore coding a Stan model, model parameters are through construction of a relatively simple Ordinary Differential Equations (ODE) model using the deSolve package. This model uses discrete, user specified values and does not incorporate uncertainty.\n\nInitial Parameters\nParameters are describe in the Table at top of page. The specific values given in this example were arbitrarily selected from the ranges evaluated in the full model (presented later in script).\n\n\nHide code\ninitial_parameters <- c(\n  beta_h = 0.95,\n  gamma_h = 0.10,\n  sigma_h = 0.25,\n  sigma_v = 0.4,\n  rho_h = 0.3,\n  rho_v = 0.85,\n  beta_v = 0.85,\n  mu_v = 0.1,\n  upsilon_h = 0.6,\n  upsilon_v = 0.35\n)\n\n\n\n\nInitial Conditions\nInitial population estimates and counts of exposed and infectious individuals.\n\n\nHide code\nN_h <- 10000   # number of vertebrate hosts\nEh <- 0        # initial hosts exposed\nIh <- 1        # initial hosts infectious\nN_v <- 300 * N_h  # number of vectors per host\nEv <- 0        # initial exposed vectors\nIv <- 1        # initial infectious vectors\n\ninitial_conditions <- c(\n  Sh = N_h - Eh - Ih,  # Susceptible hosts\n  Eh = Eh,             # Exposed hosts\n  Ih = Ih,             # Infectious hosts\n  Rh = 0,              # Recovered hosts\n  Sv = N_v - Iv - Ev,  # Susceptible vectors\n  Ev = Ev,             # Exposed vectors\n  Iv = Iv              # Infectious vectors\n)\n\n\n\n\nODE Function\nResults from this exploratory model can be examined more thoroughly on the SEIR-SEI ShinyApp, which uses the same underlying function as given here.\n\n\nHide code\nseirsei_ode <- function(t, state, parameters) {\n  with(as.list(c(state, parameters)), {\n    \n    lambda_h = upsilon_h * beta_h * Iv / N_v\n    lambda_v = upsilon_v * beta_v * Ih / N_h\n    \n    dSh = -lambda_h * Sh\n    dEh = lambda_h * Sh - sigma_h * Eh\n    dIh = sigma_h * Eh*rho_h - gamma_h * Ih\n    dRh = gamma_h * Ih\n    dSv = mu_v * N_v - lambda_v * Sv - mu_v * Sv\n    dEv = lambda_v * Sv - (sigma_v + mu_v) * Ev\n    dIv = sigma_v * Ev*rho_v - mu_v * Iv\n    \n    return(list(c(dSh, dEh, dIh, dRh, dSv, dEv, dIv)))\n  })\n}\n\n\n\n\nTime Steps\n\n\nHide code\ntimes <- seq(0, 365, by = 1)\n\n\n\n\nRun Model\n\n\nHide code\nout <- as.data.frame(\n  ode(y = initial_conditions, times = times, func = seirsei_ode, parms = initial_parameters)\n)\n\n\n\n\nPlot Results\n\n\nHide code\nplot_ode_dynamics(out)\n\n\n\n\n\nFigure 2: Host population dynamics from exploratory model.\n\n\n\n\n\n\nHide code\ncompare_ei_incidence(out, gamma_h=initial_parameters[\"gamma_h\"])\n\n\n\n\n\nFigure 3: Comparison of incident infections. Line labeled Infected indicates the number of new indiduals added to the Exposed compartment per time step, whereas the line labeled Symptomatic refers to the number of new individuals added to the infectious compartment. The ratio of the sums for the Infected and Symptomatic curves is shown as Estimated rho in the plot. This reverse calculation demonstrates what the rho competency parameter is doing in the model."
  },
  {
    "objectID": "overview.html#bayesian-model",
    "href": "overview.html#bayesian-model",
    "title": "Overview",
    "section": "Bayesian Model",
    "text": "Bayesian Model\nHaving demonstrated model parameter relationships using the ODE function above, a full Bayesian model is next constructed in Stan. The Bayesian approach allows for parameters to specified based on what is currently understood about VSV hosts, vectors, and epidemiology. This done through prior distribution specifications. The Bayesian approach also provides for better accounting of uncertainty in the model.\nIn addition to translating the SEIR-SEI equations (Equation 1) to the Stan language, a likelihood function is needed as well as incorporation of an additional observation error term to help account for the difference between disease cases as observed and documented and the case number (theoretically) needed to propagate the disease, assuming the model’s mechanistic parameters accurately reflect the reality of the VS epidemiology.\n\nPrior Model\nBefore incorporating observed data into the model, a prior model is coded and evaluated to ensure that assumptions about prior distributions are reasonable.\n\nPrior model code\nfunctions {\n    // SEIR-SEI function\n  real[] seirsei(real t, real[] y, real[] theta, \n             real[] x_r, int[] x_i) {\n\n      real N_h = x_i[1];        // parameters are described in table above\n      real beta_h = theta[1];\n      real gamma_h = theta[2];\n      real sigma_h = theta[3];\n      real sigma_v = theta[4];\n      real rho_h = theta[5];\n      real rho_v = theta[6];\n      real beta_v = theta[7];\n      real mu_v = theta[8];\n      real upsilon_h = theta[9];\n      real upsilon_v = theta[10];\n      real i_0 = theta[11];     // initial conditions\n      real e_0 = theta[12];\n      real ev_0 = theta[13];\n      real iv_0 = theta[14];\n      real N_v = theta[15];\n      \n      // initial compartment sizes\n      real init[7] = {N_h - i_0 - e_0, e_0, i_0, 0, N_v - iv_0 - ev_0, ev_0, iv_0}; \n      \n      real Sh = y[1] + init[1]; // compartments\n      real Eh = y[2] + init[2];\n      real Ih = y[3] + init[3];\n      real Rh = y[4] + init[4];\n      real Sv = y[5] + init[5];\n      real Ev = y[6] + init[6];\n      real Iv = y[7] + init[7];\n      \n      // FORCE of Infection\n      real lambda_h = upsilon_h * beta_h * Iv / N_v;\n      real lambda_v = upsilon_v * beta_v * Ih / N_h;\n      \n      // differential equations\n      real dS_dt = -lambda_h * Sh;\n      real dE_dt =  lambda_h * Sh - sigma_h * Eh;\n      real dI_dt = sigma_h * Eh*rho_h - gamma_h * Ih;\n      real dR_dt =  gamma_h * Ih;\n      \n      real dSv_dt = mu_v*N_v - lambda_v*Sv - mu_v*Sv;\n      real dEv_dt = lambda_v*Sv - (sigma_v + mu_v)*Ev;\n      real dIv_dt =  sigma_v * Ev*rho_v - mu_v*Iv;\n     \n      return {dS_dt, dE_dt, dI_dt, dR_dt, dSv_dt, dEv_dt, dIv_dt};\n  }\n}\ndata {\n  int<lower=1> n_days; // number of days\n  real t0;            // initial step\n  real ts[n_days];    // time steps\n  int N_h;            // host population size\n  int N_v;            // vector population size\n}\ntransformed data {\n  real x_r[0];        // data array\n  int x_i[1] = { N_h };   // array with host population size\n}\nparameters {\n  real<lower=0, upper=1> beta_h; // parameters, see table above\n  real<lower=0> gamma_h;\n  real<lower=0> sigma_h;\n  real<lower=0> sigma_v;\n  real<lower=0, upper=1> rho_h;\n  real<lower=0, upper=1> rho_v;\n  real<lower=0, upper=1> beta_v;\n  real<lower=0> mu_v;\n  real<lower=0> upsilon_h;\n  real<lower=0> upsilon_v;\n  real<lower=0> phi_inv;\n  real<lower=0> i_0; \n  real<lower=0> e_0; \n  real<lower=0> ev_0; \n  real<lower=0> iv_0; \n}\ntransformed parameters{\n  real y[n_days, 7];        // outputs, state variables\n  real incidence[n_days - 1];   // incidence \n  real phi = 1. / phi_inv;    // dispersian parameter for NegBinomial\n  real theta[15] = {beta_h, gamma_h, sigma_h, sigma_v, rho_h, rho_v, beta_v, mu_v, upsilon_h, upsilon_v, i_0, e_0, ev_0, iv_0, N_v};\n  \n  // solve ODEs using Runge-Kutta 45 integration\n  y = integrate_ode_rk45(seirsei, rep_array(0.0, 7), t0, ts, theta, x_r, x_i);\n  \n  // daily incidence\n  for (i in 1:n_days-1){\n    incidence[i] = -(y[i+1, 2] - y[i, 2] + y[i+1, 1] - y[i, 1]) + 1e-8;\n  }\n}\nmodel { // model priors\n  beta_h ~ beta(10, 2);\n  gamma_h ~ lognormal(log(0.13), 0.1);  \n  sigma_h ~ lognormal(log(0.12), 0.1);\n  sigma_v ~ lognormal(log(0.4), 0.1);\n  rho_h ~ beta(5, 10);\n  rho_v ~ beta(10, 2); \n  beta_v ~ beta(10, 2);\n  mu_v ~ lognormal(log(0.1), 0.1);\n  upsilon_h ~ lognormal(log(0.6), 0.1);\n  upsilon_v ~ lognormal(log(0.3), 0.1);\n  phi_inv ~ exponential(2);\n  i_0 ~ lognormal(0, 0.1);\n  e_0 ~ lognormal(0, 0.1);\n  ev_0 ~ lognormal(0, 0.1);\n  iv_0 ~ lognormal(0, 0.1);\n}\ngenerated quantities {\n  real duration = 1 / gamma_h; // disease duration\n  real incub_h = 1 / sigma_h;   // intrinsic incubation period\n  real incub_v = 1/ sigma_v;    // extrinsic incubation period\n  real pred_infected[n_days-1];  // predicted incidence\n  pred_infected = neg_binomial_2_rng(incidence, phi); // sample from NegBinomial\n}\n\n\nNegativeBinomial Sampling\nNote that the Stan code above includes a negative binomial distribution that samples from estimated incidence. The SEIR-SEI ODE equations estimate prevalence but not incidence. Therefore, the code first estimates incidence (new infections each day) using the susceptible (S) and exposed (E) compartments. That code is shown in the transformed parameters block as,\nfor (i in 1:n_days-1){\n    incidence[i] = -(y[i+1, 2] - y[i, 2] + y[i+1, 1] - y[i, 1]) + 1e-8;\n  }\nLater in the generated quantities block, incidence is used in sampling from the NgBinomial,\nreal pred_infected[n_days-1]; \n  pred_infected = neg_binomial_2_rng(incidence, phi); \nConsdering that incidence is estimated from the daily change (\\Delta text{I}_{t})in infections (virus exposures), and this quantity is used to sample from the NegBinomial, the notation with prior distributions couldbe shown as,\n\\begin{align} \\nonumber\n    \\text{Y}_{t}|\\theta &\\sim \\text{NegBinomial}(\\text{Y}|\\Delta\\text{I}_{t}, \\phi) \\\\ \\nonumber\n    \\theta &= \\{\\upsilon_h,\\upsilon_v, \\beta_h, \\beta_v, \\sigma_h, \\sigma_v, \\gamma_h, \\mu, \\rho \\} \\\\ \\nonumber\n    \\upsilon_h &\\sim \\text{Lognormal}(log(0.25), 0.1) \\\\ \\nonumber\n    \\upsilon_v &\\sim \\text{Lognormal}(log(0.15), 0.1) \\\\ \\nonumber\n    \\beta_h &\\sim \\text{Beta}(10, 1) \\\\ \\nonumber\n    \\beta_v &\\sim \\text{Beta}(1, 10) \\\\\n    \\sigma_h &\\sim \\text{Lognormal}(log(0.15), 0.1) \\\\ \\nonumber\n    \\sigma_v &\\sim \\text{Lognormal}(log(0.3), 0.1) \\\\ \\nonumber\n    \\rho_h &\\sim \\text{Beta}(10, 100) \\\\ \\nonumber\n    \\rho_v &\\sim \\text{Beta}(5, 10) \\\\ \\nonumber\n    \\gamma_h &\\sim \\text{Lognormal}(log(0.085), 0.1) \\\\ \\nonumber\n    \\mu &\\sim \\text{Lognormal}(log(0.1), 0.1) \\\\ \\nonumber\n    {1}/{\\phi} &\\sim \\text{Exponential}(2) \\\\ \\nonumber\n\\end{align}\n\n\nPrior model setup\nOrganize data needed to run the prior model.\n\n\nHide code\n# total host population\nN = 14160\n\n# time steps \nn_days = 365 \nt = seq(0, n_days, by = 1)\nt0 = 0 \nt = t[-1]\n\n# orgainize data for Stan \ndata_seir = list(n_days = n_days, \n                 t0 = t0, \n                 ts = t, \n                 N_h = N, \n                 N_v = 300*N)\n\nstr(data_seir)\n\n\nList of 5\n $ n_days: num 365\n $ t0    : num 0\n $ ts    : num [1:365] 1 2 3 4 5 6 7 8 9 10 ...\n $ N_h   : num 14160\n $ N_v   : num 4248000\n\n\nHide code\n# number of MCMC steps\nniter = 2000\n\n# number of chains, only a short run for prior model\nnum_chains <- 2\n\n# unique initial values for each chain\ninit_list <- vector(\"list\", num_chains)\n\nfor (i in 1:num_chains) {\n  \n  init_list[[i]] <- list(beta_h = rbeta(1, 10, 1),\n                         gamma_h = rlnorm(1, log(0.15), 0.1),\n                         sigma_h = rlnorm(1, log(0.17), 0.1),                         \n                         sigma_v = rlnorm(1, log(0.3), 0.1),\n                         beta_v = rbeta(1, 15, 100),\n                         mu_v = rlnorm(1, log(0.1), 0.1),\n                         upsilon_h = rlnorm(1, log(0.25), 0.1),\n                         upsilon_v = rlnorm(1, log(0.15), 0.1),   \n                         i_0 = runif(1, 1, 2),\n                         e_0 = runif(1, 1, 2),\n                         ev_0 = runif(1, 1, 2),\n                         iv_0 = runif(1, 1, 2))\n}\n\n\n\n\nRead stan model\nThe Stan code above is saved as a text file. It is read in to memory.\n\n\nHide code\nseirsei.st = stan_model(\"inst/stan/vsv_prior.stan\")\n\n\nrecompiling to avoid crashing R session\n\n\n\n\nRun prior model\nData, model code, initial values are run. This model has been verified to run, however to reduce run time, a saved copy is loaded below.\n\n\nHide code\nprior_model <- sampling(seirsei.st,\n                        data = data_seir,\n                        iter = niter,\n                        chains = num_chains,\n                        cores = parallel::detectCores(),\n                        warmup = 500,\n                        save_warmup = FALSE,\n                        init = init_list, \n                        seed = 1976) \n\n\nload saved model\n\n\nHide code\nprior_model <- readRDS(here(\"assets/prior_model.rds\"))\n  \nclass(prior_model)\n\n\n[1] \"stanfit\"\nattr(,\"package\")\n[1] \"rstan\"\n\n\n\n\nCheck results\n\n\nHide code\nplot_params_posteriors(prior_model)\n\n\nNo id variables; using all as measure variables\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\nFigure 4: Distributions from modeled priors. Dashed lines show the median value for each parameter.\n\n\n\n\n\n\nHide code\nplot_sample_trajectories(prior_model, truth_df=truth_df, n_draws = 100)\n\n\n\n\n\nFigure 5: Random draws from posterior predictive distribution. Blue lines show sampled trajectories exceeding the model estimated median values for each day, where as the height of the orange color gives the estimated daily median. Height of red circles indicate observed daily incidence.\n\n\n\n\n\n\n\nFull Stan Model\nfunctions {\n  real[] seirsei(real t, real[] y, real[] theta, \n             real[] x_r, int[] x_i) {\n\n      real N_h = x_i[1];\n     \n      real beta_h = theta[1];\n      real gamma_h = theta[2];\n      real sigma_h = theta[3];\n      real sigma_v = theta[4];\n      real rho_h = theta[5];\n      real rho_v = theta[6];\n      real beta_v = theta[7];\n      real mu_v = theta[8];\n      real upsilon_h = theta[9];\n      real upsilon_v = theta[10];\n      real i_0 = theta[11];\n      real e_0 = theta[12];\n      real ev_0 = theta[13];\n      real iv_0 = theta[14];\n      real N_v = theta[15];\n      \n      real init[7] = {N_h - i_0 - e_0, e_0, i_0, 0, N_v - iv_0 - ev_0, ev_0, iv_0}; \n      real Sh = y[1] + init[1];\n      real Eh = y[2] + init[2];\n      real Ih = y[3] + init[3];\n      real Rh = y[4] + init[4];\n      real Sv = y[5] + init[5];\n      real Ev = y[6] + init[6];\n      real Iv = y[7] + init[7];\n      \n      real lambda_h = upsilon_h * beta_h * Iv / N_v;\n      real lambda_v = upsilon_v * beta_v * Ih / N_h;\n      \n      real dS_dt = -lambda_h * Sh;\n      real dE_dt =  lambda_h * Sh - sigma_h * Eh;\n      real dI_dt = sigma_h * Eh*rho_h - gamma_h * Ih;\n      real dR_dt =  gamma_h * Ih;\n      \n      real dSv_dt = mu_v*N_v - lambda_v*Sv - mu_v*Sv;\n      real dEv_dt = lambda_v*Sv - (sigma_v + mu_v)*Ev;\n      real dIv_dt =  sigma_v * Ev*rho_v - mu_v*Iv;\n     \n      return {dS_dt, dE_dt, dI_dt, dR_dt, dSv_dt, dEv_dt, dIv_dt};\n  }\n}\ndata {\n  int<lower=1> n_days;\n  real t0;\n  real ts[n_days];\n  int N_h;\n  int N_v;\n  int cases[n_days];\n}\ntransformed data {\n  real x_r[0];\n  int x_i[1] = { N_h };\n}\nparameters {\n  real<lower=0, upper=1> beta_h;\n  real<lower=0> gamma_h;\n  real<lower=0> sigma_h;\n  real<lower=0> sigma_v;\n  real<lower=0, upper=1> rho_h;\n  real<lower=0, upper=1> rho_v;\n  real<lower=0, upper=1> beta_v;\n  real<lower=0> mu_v;\n  real<lower=0> upsilon_h;\n  real<lower=0> upsilon_v;\n  real<lower=0> phi_inv;\n  real<lower=0, upper=1> kappa;\n  real<lower=0> i_0; \n  real<lower=0> e_0; \n  real<lower=0> ev_0; \n  real<lower=0> iv_0; \n}\ntransformed parameters{\n  real y[n_days, 7];\n  real incidence[n_days - 1];\n  real phi = 1. / phi_inv;\n  real theta[15] = {beta_h, gamma_h, sigma_h, sigma_v, rho_h, rho_v, beta_v, mu_v, upsilon_h, upsilon_v, i_0, e_0, ev_0, iv_0, N_v};\n  y = integrate_ode_rk45(seirsei, rep_array(0.0, 7), t0, ts, theta, x_r, x_i);\n  for (i in 1:n_days-1){\n    incidence[i] = -(y[i+1, 2] - y[i, 2] + y[i+1, 1] - y[i, 1])*kappa + 1e-8;\n  }\n}\nmodel {\n  beta_h ~ beta(10, 1);\n  gamma_h ~ lognormal(log(0.15), 0.1);  \n  sigma_h ~ lognormal(log(0.17), 0.1);\n  sigma_v ~ lognormal(log(0.3), 0.1);\n  rho_h ~ beta(10, 100);\n  rho_v ~ beta(5, 10); \n  beta_v ~ beta(1, 10);\n  mu_v ~ lognormal(log(0.1), 0.1);\n  upsilon_h ~ lognormal(log(0.25), 0.1);\n  upsilon_v ~ lognormal(log(0.15), 0.1);\n  phi_inv ~ exponential(2);\n  kappa ~ beta(15, 100);\n  i_0 ~ lognormal(0, 0.1);\n  e_0 ~ lognormal(0, 0.1);\n  ev_0 ~ lognormal(0, 0.1);\n  iv_0 ~ lognormal(0, 0.1);\n\n  cases[1:(n_days-1)] ~ neg_binomial_2(incidence, phi);\n}\ngenerated quantities {\n  real duration = 1 / gamma_h;\n  real incub_h = 1 / sigma_h;\n  real incub_v = 1/ sigma_v;\n  real log_lik[n_days-1];\n  real pred_infected[n_days-1];\n  \n  pred_infected = neg_binomial_2_rng(incidence, phi);\n  \n  for (i in 1:(n_days - 1)) {\n    log_lik[i] = neg_binomial_2_lpmf(cases[i] | incidence[i], phi);\n  }\n}"
  },
  {
    "objectID": "overview.html#prior-predictive",
    "href": "overview.html#prior-predictive",
    "title": "Overview",
    "section": "Prior Predictive",
    "text": "Prior Predictive"
  }
]